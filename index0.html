<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>ç²’å­åœ£è¯æ ‘ Â· æ‰‹åŠ¿äº¤äº’</title>
  <style>
    :root{
      --bg0:#07060a;
      --bg1:#151018;
      --gold:#ffd36a;
      --gold2:#ffefb0;
      --red:#ff2a2a;
      --green:#1f6b3a;
      --ui: rgba(18,14,22,.62);
      --ui2: rgba(255,255,255,.08);
    }
    html,body{margin:0;height:100%;background:radial-gradient(1200px 800px at 50% 35%, #211326 0%, var(--bg1) 35%, var(--bg0) 100%); overflow:hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft YaHei", Arial;}
    #wrap{position:fixed; inset:0;}
    canvas{display:block; width:100%; height:100%; touch-action:none;}
    /* é¡¶éƒ¨ UI */
    #ui{
      position:fixed; left:14px; top:14px; z-index:20;
      display:flex; flex-direction:column; gap:10px;
      min-width:min(360px, calc(100vw - 28px));
      pointer-events:auto;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 32px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:10px 12px;
      color:rgba(255,255,255,.92);
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .btn{
      cursor:pointer; user-select:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      letter-spacing:.2px;
      display:inline-flex; align-items:center; gap:8px;
      transition: transform .12s ease, background .18s ease, border-color .18s ease;
    }
    .btn:active{transform: scale(.98);}
    .btn.on{background: rgba(255,211,106,.12); border-color: rgba(255,211,106,.35);}
    .btn.flash{animation: flash 1.0s ease-in-out 0s 3;}
    @keyframes flash{0%,100%{box-shadow:none} 50%{box-shadow:0 0 0 3px rgba(255,211,106,.35), 0 0 18px rgba(255,211,106,.28)}}
    .hint{font-size:12px; line-height:1.35; color:rgba(255,255,255,.78);}
    .hint b{color:rgba(255,243,205,.92)}
    .file{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 10px; border-radius:12px;
      border:1px dashed rgba(255,255,255,.22);
      background: rgba(0,0,0,.18);
    }
    input[type="file"]{max-width:220px; color:rgba(255,255,255,.88)}
    /* ä¸­é—´å¼€å§‹æŒ‰é’® */
    #startOverlay{
      position:fixed; inset:0; z-index:50;
      display:grid; place-items:center;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(255,211,106,.10) 0%, rgba(255,42,42,.06) 25%, rgba(0,0,0,.70) 70%),
        linear-gradient(180deg, rgba(10,7,14,.92), rgba(0,0,0,.94));
      backdrop-filter: blur(4px);
      transition: opacity .35s ease, visibility .35s ease;
    }
    #startOverlay.hide{opacity:0; visibility:hidden; pointer-events:none;}
    .startCard{
      width:min(520px, calc(100vw - 44px));
      border-radius:22px;
      padding:22px 18px 18px;
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
      box-shadow: 0 18px 50px rgba(0,0,0,.55);
      text-align:center;
      color:rgba(255,255,255,.93);
    }
    .startTitle{font-size:22px; font-weight:900; letter-spacing:.6px; margin:0 0 10px;}
    .startSub{margin:0 0 16px; font-size:13px; color:rgba(255,255,255,.78); line-height:1.45;}
    #startBtn{
      width:100%;
      border:none;
      cursor:pointer;
      padding:16px 18px;
      border-radius:18px;
      font-size:18px;
      font-weight:950;
      letter-spacing:.8px;
      color:#1b0f08;
      background: linear-gradient(90deg, #ffe08a, #ffd36a, #ffefb0);
      box-shadow: 0 12px 30px rgba(255,211,106,.22), inset 0 1px 0 rgba(255,255,255,.65);
      transition: transform .12s ease, filter .2s ease;
    }
    #startBtn:active{transform: scale(.985);}
    .smallTip{margin-top:12px; font-size:12px; color:rgba(255,255,255,.72);}
    .smallTip span{color:rgba(255,211,106,.92); font-weight:800;}
    /* Toast */
    #toast{
      position:fixed; left:50%; bottom:18px; transform:translateX(-50%);
      z-index:60; pointer-events:none;
      background: rgba(0,0,0,.56);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      color:rgba(255,255,255,.92);
      padding:10px 12px;
      border-radius:14px;
      font-size:13px;
      max-width:min(520px, calc(100vw - 28px));
      opacity:0; transition: opacity .25s ease;
    }
    #toast.show{opacity:1;}
    /* æ”¾å¤§ç…§ç‰‡ DOM å±‚ï¼ˆä¿è¯æ­£é¢å®Œæ•´+é«˜æ¸…ï¼‰ */
    #photoOverlay{
      position:fixed; inset:0; z-index:40;
      display:none; place-items:center;
      pointer-events:none;
    }
    #photoOverlay.show{display:grid;}
    #photoCard{
      width:min(86vw, 720px);
      height:min(68vh, 520px);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 22px 60px rgba(0,0,0,.62);
      border:1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      transform: scale(.90);
      opacity:0;
      transition: transform .22s cubic-bezier(.2,.9,.25,1.1), opacity .18s ease;
    }
    #photoOverlay.show #photoCard{transform: scale(1); opacity:1;}
    #photoImg{width:100%; height:100%; object-fit:contain; background: rgba(0,0,0,.35);}
    /* è¿›å…¥ç…§ç‰‡æ€ï¼šç»™ä¸»ç”»å¸ƒä¸€ä¸ªâ€œæ™¯æ·±è™šåŒ–â€ */
    body.photo-mode canvas{filter: blur(8px) brightness(1.05) saturate(1.05); transition: filter .18s ease;}
    body:not(.photo-mode) canvas{filter: none; transition: filter .18s ease;}
  </style>
</head>

<body>
  <div id="wrap"></div>

  <!-- é¡¶éƒ¨ UI -->
  <div id="ui">
    <div class="panel">
      <div class="row">
        <div id="camBtn" class="btn"><span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span></div>
        <div id="musicBtn" class="btn"><span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span></div>
        <div class="file">
          <span>ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡(â‰¤7)</span>
          <input id="fileInput" type="file" accept="image/*" multiple />
        </div>
      </div>
      <div class="hint" style="margin-top:8px">
        æ‰‹åŠ¿ï¼š<b>æ¡æ‹³</b>â†’åˆæ‹¢ï¼›<b>äº”æŒ‡å¼ å¼€</b>â†’æ•£å¼€ï¼›æ•£å¼€æ—¶<b>ç§»åŠ¨æ‰‹</b>â†’æ—‹è½¬è§†è§’ï¼›<b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b>â†’æŠ“å–æ”¾å¤§ç…§ç‰‡ï¼Œ<b>åˆ†å¼€</b>â†’å›åˆ°åŸä½ã€‚<br/>
        æé†’ï¼šæ‰‹æœºè‹¥æ— å£°éŸ³ï¼Œè¯·å…ˆ<b>ç‚¹ä¸€ä¸‹é¡µé¢</b>æˆ–ç‚¹<b>å¼€å§‹ä½“éªŒ</b>æŒ‰é’®ã€‚
      </div>
    </div>
  </div>

  <!-- ä¸­é—´å¼€å§‹æŒ‰é’®ï¼ˆä¸€æ¬¡ç‚¹å‡»ï¼šå°è¯•éŸ³ä¹ + è¯·æ±‚æ‘„åƒå¤´æƒé™/æç¤ºï¼‰ -->
  <div id="startOverlay">
    <div class="startCard">
      <h2 class="startTitle">âœ¨ åœ£è¯æ ‘ Â· å¼€å§‹ä½“éªŒ</h2>
      <p class="startSub">ç‚¹ä¸€æ¬¡å°±ä¼šå°è¯•æ’­æ”¾åœ£è¯BGMï¼Œå¹¶è¯·æ±‚æ‘„åƒå¤´æƒé™ç”¨äºæ‰‹åŠ¿äº¤äº’ã€‚<br/>ï¼ˆè‹¥ä½ ä¸æƒ³å¼€æ‘„åƒå¤´ï¼Œä¹Ÿå¯åªçœ‹è§†è§‰æ•ˆæœï¼‰</p>
      <button id="startBtn">å¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰</button>
      <div class="smallTip">å»ºè®®ç”¨ <span>Chrome / Edge / Safari</span> æ‰“å¼€ï¼Œå…è®¸æ‘„åƒå¤´åä½“éªŒæœ€ä½³ã€‚</div>
    </div>
  </div>

  <!-- Toast -->
  <div id="toast"></div>

  <!-- æ”¾å¤§ç…§ç‰‡ï¼ˆæ­£é¢å®Œæ•´ï¼Œé«˜æ¸…ï¼‰ -->
  <div id="photoOverlay">
    <div id="photoCard">
      <img id="photoImg" alt="photo" />
    </div>
  </div>

  <!-- å…¬æœ‰é¢†åŸŸ BGMï¼ˆWikimedia Commons Â· USAF Bandï¼‰ -->
  <audio id="bgm" preload="auto" loop playsinline
    src="https://upload.wikimedia.org/wikipedia/commons/3/32/Carol_of_the_Bells_-_Concert_Band_-_United_States_Air_Force_Band_of_the_Rockies.mp3"></audio>

  <!-- MediaPipe Hands (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";

    /* ------------------ å·¥å…·ï¼šToast ------------------ */
    const toastEl = document.getElementById("toast");
    let toastTimer = null;
    function toast(msg, ms=1800){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=>toastEl.classList.remove("show"), ms);
    }

    /* ------------------ éŸ³ä¹æ§åˆ¶ï¼ˆæ›´ä¸æ»‘ï¼šHTMLAudio + æ·¡å…¥æ·¡å‡ºï¼‰ ------------------ */
    const bgm = document.getElementById("bgm");
    let musicOn = false;
    let musicFadeRAF = 0;
    function setMusic(on){
      musicOn = on;
      cancelAnimationFrame(musicFadeRAF);
      const target = on ? 0.85 : 0.0; // æ¸©æŸ”ä¸€ç‚¹
      const start = bgm.volume ?? 0;
      const t0 = performance.now();
      const dur = 450; // æ·¡å…¥æ·¡å‡ºæ›´ä¸æ»‘
      const step = (t)=>{
        const p = Math.min(1, (t - t0) / dur);
        bgm.volume = start + (target - start) * (p*p*(3-2*p));
        if(p < 1) musicFadeRAF = requestAnimationFrame(step);
      };
      musicFadeRAF = requestAnimationFrame(step);

      if(on){
        bgm.muted = false;
        bgm.play().catch(()=>{
          // iOS/æ‰‹æœºå¯èƒ½éœ€è¦å†ç‚¹ä¸€æ¬¡
          toast("å¦‚æœæ²¡å£°éŸ³ï¼šè¯·å†ç‚¹ä¸€æ¬¡â€œéŸ³ä¹ï¼šå¼€å¯â€æˆ–ç‚¹ä¸€ä¸‹é¡µé¢", 2400);
        });
      }else{
        // ä¸ç«‹åˆ» pauseï¼Œè®©æ·¡å‡ºå®Œæˆåå†åœ
        setTimeout(()=>{ try{ bgm.pause(); }catch{} }, 520);
      }
    }

    /* ------------------ Three åŸºç¡€ ------------------ */
    const wrap = document.getElementById("wrap");
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15; // æ›´æ˜äº®ã€æ›´æš–
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x07060a, 0.038);

    const camera = new THREE.PerspectiveCamera(48, window.innerWidth/window.innerHeight, 0.08, 80);
    camera.position.set(0, 2.5, 8.2);

    /* è‡ªé€‚é…ï¼šæ‰‹æœº/å¹³æ¿/ç”µè„‘æ ‘ä½“æ¯”ä¾‹ä¸é•œå¤´è·ç¦» */
    const rig = new THREE.Group();
    scene.add(rig);

    function applyResponsive(){
      const w = window.innerWidth, h = window.innerHeight;
      const aspect = w / h;
      const short = Math.min(w, h);
      // æ ‘æ•´ä½“ç¼©æ”¾ï¼šæ‰‹æœºç•¥å°ã€æ¡Œé¢ç•¥å¤§
      const scale = THREE.MathUtils.clamp(short / 820, 0.78, 1.18);
      rig.scale.setScalar(scale);

      // é•œå¤´ï¼šæ‰‹æœºçºµå‘é€‚å½“æ‹‰è¿œï¼Œé¿å…å¤ªæŒ¤
      const isPhone = short < 520 || aspect < 0.75;
      camera.fov = isPhone ? 56 : 48;
      camera.position.z = isPhone ? 9.4 : 8.2;
      camera.position.y = isPhone ? 2.75 : 2.5;
      camera.updateProjectionMatrix();

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, isPhone ? 1.75 : 2));
    }

    /* ç¯å…‰ï¼šæš–ã€ç”µå½±æ„Ÿ */
    const amb = new THREE.AmbientLight(0xffe6b8, 0.55);
    scene.add(amb);

    const key = new THREE.DirectionalLight(0xfff0d6, 1.05);
    key.position.set(4, 6, 4);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0xffd36a, 0.55);
    rim.position.set(-5, 4, -4);
    scene.add(rim);

    const glowLight = new THREE.PointLight(0xffd36a, 1.0, 16, 2.0);
    glowLight.position.set(0, 3.2, 2.6);
    scene.add(glowLight);

    /* ------------------ åœ£è¯æ ‘ï¼šå±‚çº§åˆ†æ + å…‰é›¾ ------------------ */
    const tree = new THREE.Group();
    rig.add(tree);

    const TREE_H = 5.2;
    const BASE_R = 2.0;

    // æ ‘æå±‚ï¼šç”¨å¾ˆå¤šçŸ­çº¿æ®µæ¨¡æ‹Ÿâ€œåˆ†æå±‚çº§â€
    const branchGeom = new THREE.BufferGeometry();
    const branchSegs = [];
    const levels = 14;
    const perLevel = 46;

    function randn(seed){
      // è½»é‡ä¼ªéšæœº
      const x = Math.sin(seed) * 10000;
      return x - Math.floor(x);
    }

    let seed = 1.234;
    for(let li=0; li<levels; li++){
      const y = (li/(levels-1)) * (TREE_H*0.92);
      const t = 1 - y/(TREE_H*0.92);
      const r = BASE_R * Math.pow(t, 0.55);
      for(let i=0;i<perLevel;i++){
        seed += 0.37;
        const a = (i/perLevel)*Math.PI*2 + randn(seed)*0.12;
        const len = 0.25 + randn(seed+2.1)*0.45;
        const sx = Math.cos(a)*r*0.82;
        const sz = Math.sin(a)*r*0.82;
        // æå°–ç¨å‘ä¸ŠæŠ¬
        const ex = Math.cos(a)*(r + len);
        const ez = Math.sin(a)*(r + len);
        const ey = y + (0.04 + randn(seed+4.2)*0.12);
        branchSegs.push(sx,y,sz,  ex,ey,ez);
      }
    }
    branchGeom.setAttribute("position", new THREE.Float32BufferAttribute(branchSegs, 3));
    const branchMat = new THREE.LineBasicMaterial({
      color: 0x1f6b3a,
      transparent:true,
      opacity: 0.62
    });
    const branches = new THREE.LineSegments(branchGeom, branchMat);
    tree.add(branches);

    // æ ‘ä½“å…‰é›¾ï¼šåŠ æ€§ç²’å­ï¼ˆä½“ç§¯æ„Ÿï¼‰
    const fogCount = 1600;
    const fogPos = new Float32Array(fogCount*3);
    const fogSize = new Float32Array(fogCount);
    const fogSeed = new Float32Array(fogCount);

    for(let i=0;i<fogCount;i++){
      seed += 0.19;
      const y = Math.pow(randn(seed+1.1), 0.85) * (TREE_H*0.98);
      const t = 1 - y/(TREE_H*0.98);
      const r = BASE_R * Math.pow(t, 0.72) * (0.2 + randn(seed+2.2)*0.9);
      const a = randn(seed+3.3)*Math.PI*2;
      const x = Math.cos(a)*r;
      const z = Math.sin(a)*r;
      fogPos[i*3+0]=x;
      fogPos[i*3+1]=y;
      fogPos[i*3+2]=z;
      fogSize[i] = 8 + randn(seed+5.1)*20;
      fogSeed[i] = randn(seed+7.7);
    }
    const fogGeom = new THREE.BufferGeometry();
    fogGeom.setAttribute("position", new THREE.BufferAttribute(fogPos,3));
    fogGeom.setAttribute("aSize", new THREE.BufferAttribute(fogSize,1));
    fogGeom.setAttribute("aSeed", new THREE.BufferAttribute(fogSeed,1));

    const fogMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending,
      uniforms:{
        uTime:{value:0},
        uColor1:{value:new THREE.Color(0xffd36a)},
        uColor2:{value:new THREE.Color(0xffefb0)},
        uOpacity:{value:0.22}
      },
      vertexShader:`
        attribute float aSize;
        attribute float aSeed;
        uniform float uTime;
        varying float vSeed;
        void main(){
          vSeed = aSeed;
          vec3 p = position;
          float w = sin(uTime*0.8 + aSeed*6.2831)*0.06;
          p.x += w;
          p.z -= w*0.9;
          vec4 mv = modelViewMatrix * vec4(p,1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = aSize * (140.0 / -mv.z);
        }
      `,
      fragmentShader:`
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uOpacity;
        varying float vSeed;
        void main(){
          vec2 uv = gl_PointCoord*2.0-1.0;
          float d = dot(uv,uv);
          float a = smoothstep(1.0, 0.0, d);
          a *= a;
          vec3 c = mix(uColor1, uColor2, vSeed);
          gl_FragColor = vec4(c, a*uOpacity);
        }
      `
    });
    const fogPts = new THREE.Points(fogGeom, fogMat);
    tree.add(fogPts);

    /* ------------------ å…ƒç´ ï¼šé‡‘/çº¢çƒã€ç«‹æ–¹ä½“ã€ç…§ç‰‡äº‘ ------------------ */
    const elements = [];
    const photoPlanes = []; // 3D å¹³é¢ï¼ˆæ ‘ä¸Šåˆ†å¸ƒï¼‰
    const photoTex = [];    // textures

    const goldMat = new THREE.MeshStandardMaterial({
      color: 0xffd36a,
      metalness: 0.95,
      roughness: 0.18,
      emissive: new THREE.Color(0x2a1a06),
      emissiveIntensity: 0.55
    });
    const redMat = new THREE.MeshStandardMaterial({
      color: 0xff2a2a,
      metalness: 0.60,
      roughness: 0.25,
      emissive: new THREE.Color(0x200008),
      emissiveIntensity: 0.35
    });

    const sphereG = new THREE.SphereGeometry(0.09, 22, 18);
    const cubeG = new THREE.BoxGeometry(0.11,0.11,0.11);

    // ç”Ÿæˆï¼šåªè¦äº®é‡‘è‰²å’Œäº®çº¢è‰²çƒ
    const BALLS = 170;
    seed = 9.87;
    for(let i=0;i<BALLS;i++){
      const isGold = (i%2===0);
      const m = isGold ? goldMat : redMat;
      const mesh = new THREE.Mesh(sphereG, m);
      tree.add(mesh);
      elements.push({
        kind:"orn",
        obj:mesh,
        compact:new THREE.Vector3(),
        scatter:new THREE.Vector3(),
        baseRot:new THREE.Euler(randn(seed+1)*0.6, randn(seed+2)*0.6, randn(seed+3)*0.6),
        wob: new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
      });
      seed += 0.41;
    }

    // å°‘é‡é‡‘è‰²ç«‹æ–¹ä½“ç‚¹ç¼€ï¼ˆé«˜çº§æ„Ÿï¼‰
    const CUBES = 48;
    for(let i=0;i<CUBES;i++){
      const mesh = new THREE.Mesh(cubeG, goldMat);
      tree.add(mesh);
      elements.push({
        kind:"cube",
        obj:mesh,
        compact:new THREE.Vector3(),
        scatter:new THREE.Vector3(),
        baseRot:new THREE.Euler(randn(seed+1)*0.8, randn(seed+2)*0.8, randn(seed+3)*0.8),
        wob: new THREE.Vector3(randn(seed+4), randn(seed+5), randn(seed+6))
      });
      seed += 0.53;
    }

    // ç…§ç‰‡å¹³é¢ï¼ˆä¸Šä¼  7 å¼ ï¼‰
    const photoFrameMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.2,
      roughness: 0.55,
      transparent:true,
      opacity:1
    });

    function makePhotoPlane(){
      const g = new THREE.PlaneGeometry(0.55, 0.38);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.05,
        roughness: 0.35,
        transparent:true,
        opacity: 0.98
      });
      const mesh = new THREE.Mesh(g, mat);
      mesh.renderOrder = 2;
      tree.add(mesh);

      // è½»è–„â€œç›¸æ¡†â€è¾¹ç¼˜
      const frame = new THREE.Mesh(new THREE.PlaneGeometry(0.59,0.42), photoFrameMat.clone());
      frame.material.opacity = 0.16;
      frame.position.z = -0.002;
      mesh.add(frame);

      return mesh;
    }

    for(let i=0;i<7;i++){
      const p = makePhotoPlane();
      photoPlanes.push(p);
      elements.push({
        kind:"photo",
        obj:p,
        compact:new THREE.Vector3(),
        scatter:new THREE.Vector3(),
        baseRot:new THREE.Euler(0,0,0),
        wob: new THREE.Vector3(Math.random(),Math.random(),Math.random()),
        photoIndex:i
      });
    }

    /* åˆ†å±‚ + å‘¨å‘å‡åŒ€ + æœ€å°é®æŒ¡ï¼ˆç®€æ´å¯æ§ï¼‰ */
    function computeAnchors(num){
      // 7 å¼ å›¾ï¼šå±‚æ•°=7ï¼Œæ¯å±‚ä¸€ä¸ªï¼Œè§’åº¦ç”¨é»„é‡‘è§’ä¿è¯å‡åŒ€
      const anchors = [];
      const golden = 2.399963229728653; // é»„é‡‘è§’
      for(let i=0;i<num;i++){
        const y = (i/(num-1))*(TREE_H*0.78) + 0.55; // åˆ†å±‚
        const t = 1 - (y/(TREE_H*0.98));
        const r = BASE_R * Math.pow(t, 0.72) * 0.92;
        const a = (i*golden) % (Math.PI*2);
        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;
        // æœ€å°é®æŒ¡ï¼šè®©é¢æœå¤–ï¼ˆç¨æŠ¬è§’åº¦ï¼‰
        const rotY = Math.atan2(x, z); // outward
        anchors.push({pos:new THREE.Vector3(x,y,z), rotY});
      }
      return anchors;
    }

    function assignCompactPositions(){
      // ornaments/cubes: åˆ†å±‚æ•£å¸ƒåœ¨æå¶
      let idx = 0;
      for(const e of elements){
        if(e.kind==="photo") continue;
        seed += 0.37;
        const y = Math.pow(randn(seed+1.2), 0.9) * (TREE_H*0.92);
        const t = 1 - y/(TREE_H*0.92);
        const r = BASE_R * Math.pow(t, 0.75);
        const a = randn(seed+2.2)*Math.PI*2;
        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;
        e.compact.set(x,y,z);

        // scatter ä½ç½®ï¼šæ›´å¤§èŒƒå›´æ¼‚æµ®
        const sr = 3.6 + randn(seed+3.3)*2.2;
        const sa = randn(seed+4.4)*Math.PI*2;
        const sy = (randn(seed+5.5)-0.35)*3.1 + 1.1;
        e.scatter.set(Math.cos(sa)*sr, sy, Math.sin(sa)*sr);

        idx++;
      }

      // photos: ä¸¥æ ¼åˆ†å±‚+å‡åŒ€
      const anchors = computeAnchors(7);
      for(let i=0;i<7;i++){
        const pe = elements.find(x=>x.kind==="photo" && x.photoIndex===i);
        pe.compact.copy(anchors[i].pos);
        // æ•£å¼€æ€ï¼šä»¥ compact ä¸ºä¸­å¿ƒå‘æ•£åˆ°æ›´å¤–åœˆï¼ˆä¸”ä¸äº’ç›¸æŒ¤ï¼‰
        const out = anchors[i].pos.clone().multiplyScalar(1.55);
        out.x += (i%2?0.55:-0.55);
        out.z += (i%2?-0.35:0.35);
        out.y += (i-3)*0.08;
        pe.scatter.copy(out);
      }
    }
    assignCompactPositions();

    /* ------------------ é¡¶éƒ¨äº”è§’æ˜Ÿï¼ˆæ›´æ˜æ˜¾ï¼Œè§’åº¦æ›´å¤§ï¼‰ ------------------ */
    function makeStar(){
      const shape = new THREE.Shape();
      const spikes = 5;
      const outer = 0.34;
      const inner = 0.14;
      let rot = Math.PI / 2 * 3;
      let cx = 0, cy = 0;
      shape.moveTo(cx, cy - outer);
      for (let i=0;i<spikes;i++){
        shape.lineTo(cx + Math.cos(rot) * outer, cy + Math.sin(rot) * outer);
        rot += Math.PI / spikes;
        shape.lineTo(cx + Math.cos(rot) * inner, cy + Math.sin(rot) * inner);
        rot += Math.PI / spikes;
      }
      shape.closePath();

      const geo = new THREE.ExtrudeGeometry(shape, {depth:0.08, bevelEnabled:true, bevelThickness:0.02, bevelSize:0.02, bevelSegments:2});
      geo.center();

      const mat = new THREE.MeshStandardMaterial({
        color: 0xffd36a,
        metalness: 0.95,
        roughness: 0.18,
        emissive: new THREE.Color(0xffb84a),
        emissiveIntensity: 0.85
      });

      const m = new THREE.Mesh(geo, mat);
      m.position.set(0, TREE_H*0.98 + 0.25, 0);
      m.rotation.set(0.18, 0.0, 0.10);
      m.scale.setScalar(1.25);
      return m;
    }
    const star = makeStar();
    tree.add(star);

    /* ------------------ ç¯ä¸²ï¼šæ ‡å‡†èºæ—‹é‡‘è‰²å…‰çº¿ï¼ˆåˆæ‹¢æ€æ ‡å‡†ï¼›æ•£å¼€æ€éšæ„æµåŠ¨ï¼‰ ------------------ */
    // ç”¨ TubeGeometry åšâ€œçœŸå®çº¿â€
    function buildHelixPoints(standardness, time){
      // standardness: 0=å¾ˆéšæ„ 1=æ ‡å‡†èºæ—‹
      const pts = [];
      const turns = 6.2;
      const steps = 220;
      for(let i=0;i<=steps;i++){
        const u = i/steps;
        const y = 0.25 + u*(TREE_H*0.92);
        const t = 1 - y/(TREE_H*0.92);
        const rBase = BASE_R * Math.pow(t, 0.65) * 0.98;

        // æ ‡å‡†èºæ—‹
        const a0 = u * turns * Math.PI*2;
        let r = rBase;
        let a = a0;

        // æ•£å¼€æ€â€œéšæ„æµåŠ¨â€ï¼šåŠ å…¥å™ªåŠ¨ï¼ˆéš timeï¼‰
        const wob = (1-standardness);
        const n1 = Math.sin(time*0.9 + u*12.0) * 0.18 * wob;
        const n2 = Math.cos(time*0.7 + u*9.0) * 0.14 * wob;
        r = rBase * (1 + n1);
        a = a0 + n2;

        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;
        pts.push(new THREE.Vector3(x,y,z));
      }
      return pts;
    }

    const helixMat = new THREE.MeshBasicMaterial({
      color: 0xffd36a,
      transparent:true,
      opacity: 0.85
    });

    let helixMesh = null;
    function rebuildHelix(standardness, time){
      if(helixMesh) tree.remove(helixMesh);
      const curve = new THREE.CatmullRomCurve3(buildHelixPoints(standardness, time));
      const geo = new THREE.TubeGeometry(curve, 220, 0.018, 10, false);
      helixMesh = new THREE.Mesh(geo, helixMat);
      helixMesh.renderOrder = 1;
      tree.add(helixMesh);

      // å°ç¯ç‚¹ï¼šæ²¿èºæ—‹åˆ†å¸ƒï¼ˆæ›´çœŸå®ï¼‰
      if(!rebuildHelix.lights){
        rebuildHelix.lights = [];
        const bulbG = new THREE.SphereGeometry(0.03, 12, 10);
        const bulbM = new THREE.MeshBasicMaterial({color:0xffefb0, transparent:true, opacity:0.95});
        for(let i=0;i<70;i++){
          const b = new THREE.Mesh(bulbG, bulbM);
          tree.add(b);
          rebuildHelix.lights.push(b);
        }
      }
      const pts = buildHelixPoints(1, time);
      rebuildHelix.lights.forEach((b, i)=>{
        const u = i/(rebuildHelix.lights.length-1);
        const idx = Math.floor(u*(pts.length-1));
        b.position.copy(pts[idx]);
      });
    }
    rebuildHelix(1, 0);

    /* ------------------ çŠ¶æ€æœºï¼šåˆæ‹¢ / æ•£å¼€ / ç…§ç‰‡æ”¾å¤§ ------------------ */
    const STATE = { COMPACT:"compact", SCATTER:"scatter", PHOTO:"photo" };
    let state = STATE.COMPACT;
    let stateTarget = STATE.COMPACT;

    let stateMix = 0; // 0=compact 1=scatter
    let mixVel = 0;

    function gotoState(next){
      if(next===STATE.PHOTO){
        stateTarget = STATE.SCATTER; // èƒŒæ™¯ä¿æŒæ•£å¼€
        state = STATE.PHOTO;
      }else{
        state = next;
        stateTarget = next;
      }
    }

    /* ------------------ ç…§ç‰‡æŠ“å–ï¼ˆpinchï¼‰ï¼šDOM æ”¾å¤§ï¼Œä¿è¯æ­£é¢å®Œæ•´é«˜æ¸… ------------------ */
    const photoOverlay = document.getElementById("photoOverlay");
    const photoImg = document.getElementById("photoImg");
    let grabbedIndex = -1;

    function enterPhotoMode(i){
      grabbedIndex = i;
      const tex = photoTex[i];
      if(tex && tex.image && tex.image.src){
        photoImg.src = tex.image.src;
      }else{
        // æ²¡ä¸Šä¼ æ—¶ç»™é»˜è®¤æç¤º
        photoImg.removeAttribute("src");
        photoImg.style.background = "rgba(0,0,0,.35)";
      }
      document.body.classList.add("photo-mode");
      photoOverlay.classList.add("show");
      gotoState(STATE.PHOTO);
    }
    function exitPhotoMode(){
      grabbedIndex = -1;
      document.body.classList.remove("photo-mode");
      photoOverlay.classList.remove("show");
      if(state===STATE.PHOTO) gotoState(STATE.SCATTER);
    }

    /* ------------------ ä¸Šä¼ å›¾ç‰‡ï¼š7 å¼  ------------------ */
    const fileInput = document.getElementById("fileInput");
    const loader = new THREE.TextureLoader();
    loader.crossOrigin = "anonymous";

    function applyTextureToPlane(i, tex){
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = true;
      tex.needsUpdate = true;

      photoTex[i] = tex;
      const plane = photoPlanes[i];
      plane.material.map = tex;
      plane.material.needsUpdate = true;
    }

    fileInput.addEventListener("change", async (e)=>{
      const files = Array.from(e.target.files || []).slice(0,7);
      if(!files.length) return;
      toast(`å·²é€‰æ‹© ${files.length} å¼ ç…§ç‰‡`, 1600);

      for(let i=0;i<7;i++){
        if(!files[i]) continue;
        const url = URL.createObjectURL(files[i]);
        await new Promise((resolve)=>{
          loader.load(url, (tex)=>{
            applyTextureToPlane(i, tex);
            // DOM æ”¾å¤§ä¹Ÿç”¨åŒä¸€ä¸ª URLï¼Œä¿è¯æ¸…æ™°
            if(i===0 && grabbedIndex===0) photoImg.src = url;
            resolve();
          }, undefined, ()=>{
            resolve();
          });
        });
      }
      // æ¸…æ‰ valueï¼Œæ–¹ä¾¿åŒåæ–‡ä»¶é‡å¤é€‰
      fileInput.value = "";
    });

    /* ------------------ ç›¸æœºæ—‹è½¬ï¼ˆæ‰‹åŠ¿æ§åˆ¶ï¼‰ ------------------ */
    let yaw = 0, pitch = -0.08, roll = 0;
    let yawT = 0, pitchT = -0.08, rollT = 0;

    function applyCamera(){
      // æ›´â€œè·Ÿæ‰‹â€ï¼šå‡å°‘æ»å
      const a = 0.40; // smoothing
      yaw += (yawT - yaw)*a;
      pitch += (pitchT - pitch)*a;
      roll += (rollT - roll)*0.25;

      pitch = THREE.MathUtils.clamp(pitch, -0.55, 0.35);

      // è®¡ç®—ç›¸æœºå›´ç»•ä¸­å¿ƒçš„è½¨é“
      const radius = camera.position.z; // å·²è‡ªé€‚é…
      const cx = 0, cy = 2.2, cz = 0;
      const x = cx + Math.sin(yaw)*radius;
      const z = cz + Math.cos(yaw)*radius;
      const y = cy + pitch*radius*0.9;

      camera.position.set(x, y, z);
      camera.lookAt(0, 2.1, 0);

      // è½»å¾® roll
      camera.rotation.z = roll;
    }

    /* ------------------ MediaPipe æ‰‹åŠ¿è¯†åˆ«ï¼šæ›´æ¸…æ™°çš„æŒ‡ä»¤åˆ†è¾¨ ------------------ */
    const camBtn = document.getElementById("camBtn");
    const musicBtn = document.getElementById("musicBtn");

    let camOn = false;
    let stream = null;
    let videoEl = null;
    let hands = null;
    let mpCamera = null;

    // æ‰‹åŠ¿å»æŠ–ï¼šè¦æ±‚è¿ç»­å¤šå¸§ç¨³å®š
    const gestureHistory = [];
    const GH = 10;

    function pushGesture(g){
      gestureHistory.push(g);
      while(gestureHistory.length>GH) gestureHistory.shift();
    }
    function stableGesture(){
      if(gestureHistory.length < GH) return null;
      const last = gestureHistory[gestureHistory.length-1];
      let same = 0;
      for(const x of gestureHistory) if(x===last) same++;
      return same >= Math.floor(GH*0.7) ? last : null;
    }

    function fingerExtended(lm, tip, pip){
      // y è¶Šå°è¶Šé ä¸Šï¼ˆé€šå¸¸æ‰‹æŒç›´ç«‹ï¼‰
      return lm[tip].y < lm[pip].y - 0.02;
    }
    function countExtended(lm){
      const idx = fingerExtended(lm, 8, 6);
      const mid = fingerExtended(lm, 12,10);
      const ring= fingerExtended(lm, 16,14);
      const pin = fingerExtended(lm, 20,18);
      // æ‹‡æŒ‡ç”¨ x åˆ¤æ–­ï¼ˆå·¦å³æ‰‹ä¼šåï¼Œä½†åªéœ€è¦â€œå¼ å¼€/æ¡æ‹³â€çš„ç²—åˆ¤æ–­ï¼‰
      const thumb = Math.abs(lm[4].x - lm[3].x) > 0.025;
      return (idx?1:0)+(mid?1:0)+(ring?1:0)+(pin?1:0)+(thumb?1:0);
    }
    function isPinching(lm){
      const dx = lm[4].x - lm[8].x;
      const dy = lm[4].y - lm[8].y;
      const d = Math.sqrt(dx*dx+dy*dy);
      return d < 0.045; // æ›´æ•æ„Ÿï¼šæåˆæ›´å®¹æ˜“è§¦å‘
    }

    // æ‰‹åŠ¿åˆ°åŠ¨ä½œï¼š
    // - æ¡æ‹³ => COMPACT
    // - äº”æŒ‡å¼ å¼€ => SCATTER
    // - æ•£å¼€ + å¼ æ‰‹ + ç§»åŠ¨ => æ—‹è½¬è§†è§’
    // - æ‹‡æŒ‡é£ŸæŒ‡æåˆ => æŠ“å–ç…§ç‰‡ï¼ˆæ”¾å¤§ï¼‰ï¼Œåˆ†å¼€ => å›åŸä½
    let pinchPrev = false;
    let lastHand = {x:0.5, y:0.5, t:0};
    let rotateActive = false;

    // é€‰ç…§ç‰‡ï¼šä»¥ pinch ç‚¹åšå±å¹•ç©ºé—´æœ€è¿‘åŒ¹é…
    const raycaster = new THREE.Raycaster();
    function pickPhotoAt(nx, ny){
      raycaster.setFromCamera(new THREE.Vector2(nx, ny), camera);
      const hits = raycaster.intersectObjects(photoPlanes, true);
      if(hits && hits.length){
        const hit = hits[0].object;
        const idx = photoPlanes.indexOf(hit.parent?.type==="Group" ? hit.parent : hit);
        return idx >= 0 ? idx : 0;
      }
      // æ—  hitï¼šæŒ‰å±å¹•è·ç¦»æ‰¾æœ€è¿‘ï¼ˆç£å¸ï¼‰
      let best = -1, bestD = 1e9;
      const v = new THREE.Vector3();
      for(let i=0;i<photoPlanes.length;i++){
        v.copy(photoPlanes[i].getWorldPosition(new THREE.Vector3())).project(camera);
        const dx = v.x - nx, dy = v.y - ny;
        const d = dx*dx + dy*dy;
        if(d<bestD){ bestD=d; best=i; }
      }
      return best;
    }

    function onHandResults(res){
      const ms = performance.now();
      const lm = res.multiHandLandmarks && res.multiHandLandmarks[0];
      if(!lm){
        pushGesture("none");
        rotateActive = false;
        return;
      }

      // å–è…•ç‚¹ï¼ˆ0ï¼‰ä½œä¸ºç§»åŠ¨æ§åˆ¶
      const wrist = lm[0];
      // é•œåƒæ§åˆ¶ï¼šæ›´ç¬¦åˆâ€œçœ‹ç€å±å¹•è‡ªå·±æ“ä½œâ€çš„ç›´è§‰
      const hx = 1 - wrist.x;
      const hy = wrist.y;

      const ext = countExtended(lm);
      const pinch = isPinching(lm);

      // åˆ¤æ–­â€œæ¡æ‹³/å¼ æ‰‹â€
      const isFist = (ext <= 1) && !pinch;
      const isOpen = (ext >= 4) && !pinch;

      // è®°å½•æ‰‹æŒæ¨ªå‘æ–¹å‘ï¼Œç»™ä¸€ç‚¹ rollï¼ˆè½»å¾®åŠ æˆï¼‰
      // ç”¨ index_mcp(5) -> pinky_mcp(17) åœ¨å±å¹•å¹³é¢è§’åº¦è¿‘ä¼¼
      const vx = (1 - lm[17].x) - (1 - lm[5].x);
      const vy = (lm[17].y) - (lm[5].y);
      const palmAngle = Math.atan2(vy, vx); // -pi..pi
      const rollTarget = THREE.MathUtils.clamp(palmAngle * 0.15, -0.22, 0.22);

      let g = "move";
      if(pinch) g = "pinch";
      else if(isFist) g = "fist";
      else if(isOpen) g = "open";
      pushGesture(g);

      const stable = stableGesture();

      // çŠ¶æ€åˆ‡æ¢ï¼šåªç”¨ç¨³å®šæ‰‹åŠ¿ï¼Œé¿å…æ··æ·†
      if(stable === "fist"){
        exitPhotoMode();
        gotoState(STATE.COMPACT);
      }else if(stable === "open"){
        if(state !== STATE.PHOTO){
          gotoState(STATE.SCATTER);
        }
      }

      // Pinchï¼šè¿›å…¥/é€€å‡ºç…§ç‰‡æ€ï¼ˆä»¥æ‹‡æŒ‡é£ŸæŒ‡æåˆä¸ºå‡†ï¼‰
      if(pinch && !pinchPrev){
        // pinch start
        if(stateTarget !== STATE.COMPACT){
          // pinch ç‚¹ï¼šç”¨ thumb+index ä¸­ç‚¹ï¼ˆæ›´å‡†ç¡®ï¼‰
          const px = 1 - ((lm[4].x + lm[8].x) * 0.5);
          const py = ((lm[4].y + lm[8].y) * 0.5);
          const nx = THREE.MathUtils.clamp(px*2 - 1, -1, 1);
          const ny = THREE.MathUtils.clamp(-(py*2 - 1), -1, 1);

          const idx = pickPhotoAt(nx, ny);
          if(idx >= 0){
            enterPhotoMode(idx);
            toast("å·²æŠ“å–ç…§ç‰‡ï¼šæ¾å¼€æåˆå³å¯å›åˆ°åŸä½", 1700);
          }
        }
      }
      if(!pinch && pinchPrev){
        // pinch end
        exitPhotoMode();
      }
      pinchPrev = pinch;

      // æ—‹è½¬è§†è§’ï¼šæ•£å¼€æ€ + å¼ æ‰‹ + ç§»åŠ¨
      // è¦æ±‚ï¼šæ‰‹åœ¨ç”»é¢å†…ç§»åŠ¨æ§åˆ¶è§’åº¦ï¼Œè·Ÿéšæ›´çµæ•ï¼›æ•´åœˆæ‘†åŠ¨ä¹Ÿèƒ½å¯¹åº”æ•´åœˆæ—‹è½¬ï¼ˆæé«˜å¢ç›Šï¼‰
      if(stateTarget === STATE.SCATTER && isOpen && !pinch && state !== STATE.PHOTO){
        const dt = Math.max(16, ms - (lastHand.t || ms));
        const dx = hx - lastHand.x;
        const dy = hy - lastHand.y;

        // å¢ç›Šï¼šæ›´è·Ÿæ‰‹ï¼ˆä½ ä¹‹å‰è¯´æ…¢ï¼Œè¿™é‡Œæ˜æ˜¾æå‡ï¼‰
        const gainYaw = Math.PI * 2.2;  // æ¨ªå‘ç§»åŠ¨ 1.0 çº¦è½¬ 2.2 åœˆ
        const gainPitch= Math.PI * 1.1;

        // åªæœ‰æ˜æ˜¾ç§»åŠ¨æ‰æ›´æ–°ï¼ˆå‡å°‘æŠ–åŠ¨ï¼‰
        if(Math.abs(dx) + Math.abs(dy) > 0.002){
          yawT += dx * gainYaw;
          pitchT += dy * gainPitch;

          // roll è½»å¾®è·Ÿéšæ‰‹æŒè§’
          rollT = rollTarget;
          rotateActive = true;
        }
        lastHand = {x:hx, y:hy, t:ms};
      }else{
        rotateActive = false;
        // roll æ…¢æ…¢å›é›¶
        rollT *= 0.92;
      }
    }

    async function startCamera(){
      if(camOn) return true;
      try{
        if(!videoEl){
          videoEl = document.createElement("video");
          videoEl.setAttribute("playsinline", "");
          videoEl.muted = true;
          videoEl.autoplay = true;
          videoEl.style.position="fixed";
          videoEl.style.left="-9999px";
          videoEl.style.top="-9999px";
          document.body.appendChild(videoEl);
        }

        stream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:"user",
            width:{ideal: 960},
            height:{ideal: 540}
          },
          audio:false
        });
        videoEl.srcObject = stream;
        await videoEl.play();

        if(!hands){
          hands = new window.Hands({
            locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
          });
          hands.setOptions({
            maxNumHands:1,
            modelComplexity:1,
            minDetectionConfidence:0.70,
            minTrackingConfidence:0.70
          });
          hands.onResults(onHandResults);
        }

        if(!mpCamera){
          mpCamera = new window.Camera(videoEl, {
            onFrame: async ()=>{
              if(hands) await hands.send({image: videoEl});
            },
            width: 960,
            height: 540
          });
        }
        mpCamera.start();

        camOn = true;
        camBtn.classList.add("on");
        camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå¼€å¯</span>";
        toast("æ‘„åƒå¤´å·²å¼€å¯ï¼šç°åœ¨å¯ä»¥ç”¨æ‰‹åŠ¿æ§åˆ¶å•¦", 1600);
        return true;
      }catch(err){
        camOn = false;
        camBtn.classList.remove("on");
        camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
        toast("æ‘„åƒå¤´å¼€å¯å¤±è´¥ï¼šè¯·æ£€æŸ¥æƒé™/ç”¨ HTTPS æ‰“å¼€", 2400);
        return false;
      }
    }

    function stopCamera(){
      if(!camOn) return;
      try{
        mpCamera && mpCamera.stop && mpCamera.stop();
      }catch{}
      try{
        if(stream){
          stream.getTracks().forEach(t=>t.stop());
          stream = null;
        }
      }catch{}
      camOn = false;
      camBtn.classList.remove("on");
      camBtn.innerHTML = "<span>ğŸ“·</span><span>æ‘„åƒå¤´ï¼šå…³é—­</span>";
      toast("å·²å…³é—­æ‘„åƒå¤´", 1200);
    }

    camBtn.addEventListener("click", async ()=>{
      if(camOn) stopCamera();
      else await startCamera();
    });

    musicBtn.addEventListener("click", ()=>{
      if(musicOn){
        setMusic(false);
        musicBtn.classList.remove("on");
        musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå…³é—­</span>";
      }else{
        setMusic(true);
        musicBtn.classList.add("on");
        musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
      }
    });

    /* ------------------ â€œå¼€å§‹ä½“éªŒï¼ˆç‚¹æˆ‘ï¼‰â€å¤§æŒ‰é’®é€»è¾‘ ------------------ */
    const startOverlay = document.getElementById("startOverlay");
    const startBtn = document.getElementById("startBtn");

    async function startExperience(){
      // 1) å…ˆè¯•ç€å¼€éŸ³ä¹ï¼ˆç”¨æˆ·æ‰‹åŠ¿è§¦å‘ï¼Œç§»åŠ¨ç«¯æ›´å®¹æ˜“æˆåŠŸï¼‰
      if(!musicOn){
        setMusic(true);
        musicBtn.classList.add("on");
        musicBtn.innerHTML = "<span>ğŸµ</span><span>éŸ³ä¹ï¼šå¼€å¯</span>";
      }
      // 2) å†è¯·æ±‚æ‘„åƒå¤´ï¼ˆå¤±è´¥å°±æç¤ºå»ç‚¹å·¦ä¸Šè§’æ‘„åƒå¤´ï¼‰
      const ok = await startCamera();
      if(!ok){
        camBtn.classList.add("flash");
        toast("è¯·ç‚¹å·¦ä¸Šè§’â€œæ‘„åƒå¤´ï¼šå¼€å¯â€ï¼Œå¹¶å…è®¸æƒé™", 2400);
        setTimeout(()=>camBtn.classList.remove("flash"), 3200);
      }
      // 3) éšè— overlay
      startOverlay.classList.add("hide");
    }
    startBtn.addEventListener("click", startExperience);

    // ç”¨æˆ·ç‚¹å‡»ä»»æ„ä½ç½®ï¼Œä¹Ÿå°è¯•æ¢å¤éŸ³ä¹ï¼ˆæ›´è´´åˆæ‰‹æœºç­–ç•¥ï¼‰
    window.addEventListener("pointerdown", ()=>{
      if(musicOn && bgm.paused){
        bgm.play().catch(()=>{});
      }
    }, {passive:true});

    /* ------------------ åŠ¨ç”»ï¼šå…ƒç´ åœ¨åˆæ‹¢/æ•£å¼€ä¹‹é—´å¹³æ»‘åˆ‡æ¢ ------------------ */
    function smoothDamp(current, target, currentVelocity, smoothTime, deltaTime){
      smoothTime = Math.max(0.0001, smoothTime);
      const omega = 2 / smoothTime;
      const x = omega * deltaTime;
      const exp = 1 / (1 + x + 0.48*x*x + 0.235*x*x*x);
      let change = current - target;
      const temp = (currentVelocity + omega * change) * deltaTime;
      currentVelocity = (currentVelocity - omega * temp) * exp;
      const output = target + (change + temp) * exp;
      return {value:output, vel:currentVelocity};
    }

    function updateElements(dt, time){
      // stateMix ç›®æ ‡
      const targetMix = (stateTarget === STATE.SCATTER) ? 1 : 0;
      const sd = smoothDamp(stateMix, targetMix, mixVel, 0.38, dt);
      stateMix = sd.value; mixVel = sd.vel;

      // èºæ—‹ç¯ä¸²ï¼šåˆæ‹¢æ€æ ‡å‡†ï¼›æ•£å¼€æ€éšæ„æµåŠ¨
      // ä¸ºäº†æ€§èƒ½ï¼Œä¸æ¯å¸§ rebuildï¼šæ¯éš”å‡ å¸§é‡å»ºä¸€æ¬¡
      updateElements._helixAcc = (updateElements._helixAcc || 0) + dt;
      if(updateElements._helixAcc > 0.085){
        updateElements._helixAcc = 0;
        const standardness = 1 - stateMix; // 0 scatter -> 1 compact
        rebuildHelix(standardness, time);
      }

      // è¿‡æ¸¡åŠ¨ç”»ï¼šå…ƒç´ ä½ç½®æ’å€¼ + æ•£å¼€æ€æ¼‚æµ®
      const focus = (state===STATE.PHOTO) ? 0.15 : 0; // è®©èƒŒæ™¯åœ¨ç…§ç‰‡æ€æ›´ç¨³å®šä¸€ç‚¹
      for(const e of elements){
        const obj = e.obj;

        // ç›®æ ‡ä½ç½®ï¼ˆmixï¼‰
        const pos = e.compact.clone().lerp(e.scatter, stateMix);

        // æ•£å¼€æ¼‚æµ®ï¼ˆéšæ„ï¼‰
        if(stateMix > 0.02){
          const w = e.wob;
          pos.x += Math.sin(time*0.9 + w.x*6.0) * 0.08 * stateMix;
          pos.y += Math.cos(time*0.8 + w.y*6.0) * 0.07 * stateMix;
          pos.z += Math.sin(time*0.7 + w.z*6.0) * 0.08 * stateMix;
        }

        // ç£å¸ï¼špinch æŠ“ç…§ç‰‡æ—¶ï¼Œè®©è¯¥ç…§ç‰‡åœ¨ 3D é‡Œä¹Ÿè½»å¾®é è¿‘é•œå¤´ï¼ˆå¼¹æ€§ï¼‰
        if(e.kind==="photo" && grabbedIndex === e.photoIndex){
          const toward = new THREE.Vector3().copy(camera.position).sub(obj.getWorldPosition(new THREE.Vector3())).normalize();
          pos.add(toward.multiplyScalar(0.55));
        }

        // å¼¹æ€§è·Ÿéš
        obj.position.lerp(pos, 0.18 + stateMix*0.08 + focus);

        // æ—‹è½¬ï¼šç…§ç‰‡é¢æœå¤–ï¼Œçƒ/ç«‹æ–¹ä½“å¾®è½¬
        if(e.kind==="photo"){
          // é¢æœå¤–ï¼ˆæœå‘ç›¸æœºç•¥ä¿®æ­£ï¼‰
          const outward = obj.position.clone(); outward.y = obj.position.y;
          const look = outward.clone().multiplyScalar(2.0);
          obj.lookAt(look);
          // ç¨æŠ¬èµ·ï¼Œæ˜¾å¾—â€œæŒ‚åœ¨æ ‘ä¸Šâ€
          obj.rotation.x += 0.18*(1-stateMix);
        }else{
          obj.rotation.x = e.baseRot.x + Math.sin(time*0.6 + e.wob.x*6.0)*0.25*stateMix;
          obj.rotation.y = e.baseRot.y + Math.cos(time*0.55+ e.wob.y*6.0)*0.22*stateMix;
          obj.rotation.z = e.baseRot.z + Math.sin(time*0.5 + e.wob.z*6.0)*0.16*stateMix;
        }

        // å‡ºæ™¯æ·±ï¼šæ•£å¼€æ€æ›´â€œç”µå½±æ„Ÿâ€
        if(e.kind!=="photo"){
          const s = (e.kind==="cube") ? 1.0 : 1.0;
          obj.scale.setScalar(s*(0.95 + stateMix*0.06));
        }
      }

      // æ˜Ÿæ˜Ÿå¾®å¾®é—ªçƒ
      star.rotation.y += dt*0.55*(0.2 + (1-stateMix)*0.8);
      star.material.emissiveIntensity = 0.85 + Math.sin(time*1.6)*0.12;

      // æå¶ä¸å…‰é›¾æ•´ä½“æ˜åº¦ï¼ˆæ›´æš–ã€æ›´é«˜çº§ï¼‰
      branchMat.opacity = 0.62 + (1-stateMix)*0.10;
      fogMat.uniforms.uOpacity.value = 0.22 + (1-stateMix)*0.08;
    }

    /* ------------------ åˆå§‹åŒ–æ ‘ä¸Šç…§ç‰‡ï¼šå¦‚æœæ²¡ä¸Šä¼ ï¼Œç”¨æ¸å˜å ä½ ------------------ */
    function makePlaceholderTexture(i){
      const c = document.createElement("canvas");
      c.width = 1024; c.height = 768;
      const g = c.getContext("2d");
      const grd = g.createLinearGradient(0,0,1024,768);
      grd.addColorStop(0, "rgba(255,211,106,0.95)");
      grd.addColorStop(0.55, "rgba(255,42,42,0.85)");
      grd.addColorStop(1, "rgba(31,107,58,0.85)");
      g.fillStyle = grd; g.fillRect(0,0,c.width,c.height);
      g.fillStyle = "rgba(0,0,0,.20)";
      g.fillRect(40,40,c.width-80,c.height-80);
      g.fillStyle = "rgba(255,255,255,.92)";
      g.font = "bold 56px system-ui, -apple-system, Segoe UI, Roboto";
      g.fillText("ä¸Šä¼ ç…§ç‰‡", 80, 180);
      g.font = "36px system-ui, -apple-system, Segoe UI, Roboto";
      g.fillStyle = "rgba(255,255,255,.78)";
      g.fillText(`ç¬¬ ${i+1} å¼ `, 80, 250);
      g.fillText("Pinch æåˆæŠ“å–æ”¾å¤§", 80, 320);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }
    for(let i=0;i<7;i++){
      applyTextureToPlane(i, makePlaceholderTexture(i));
    }

    /* ------------------ æ¸²æŸ“å¾ªç¯ ------------------ */
    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;
      const time = now/1000;

      fogMat.uniforms.uTime.value = time;

      // æ›´æ–°å…ƒç´ ä¸çŠ¶æ€åŠ¨ç”»
      updateElements(dt, time);

      // ç›¸æœºæ›´æ–°
      applyCamera();

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    /* ------------------ Resize ------------------ */
    function onResize(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      applyResponsive();
    }
    window.addEventListener("resize", onResize, {passive:true});
    window.addEventListener("orientationchange", ()=>setTimeout(onResize, 200), {passive:true});

    /* ------------------ å¯åŠ¨ ------------------ */
    applyResponsive();
    requestAnimationFrame(tick);

    // é»˜è®¤ï¼šæ ‘æ˜¯åˆæ‹¢æ€ï¼ˆåˆå§‹çŠ¶æ€ï¼‰ï¼ŒéŸ³ä¹/æ‘„åƒå¤´é»˜è®¤å…³é—­ï¼ˆç”±â€œå¼€å§‹ä½“éªŒâ€ä¸€é”®æ‰“å¼€ï¼‰
    gotoState(STATE.COMPACT);

    // é˜²æ­¢é®æŒ¡æç¤ºï¼šä¸å†æ˜¾ç¤ºâ€œåå¤„ç†åŠ è½½å¤±è´¥...â€ä¹‹ç±»ä¿¡æ¯ï¼ˆè¿™é‡Œæœ¬ç‰ˆæœ¬ä¸ä½¿ç”¨åå¤„ç†ï¼‰
  </script>
</body>
</html>
